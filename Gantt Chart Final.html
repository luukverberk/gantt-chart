<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gantt Chart Planning & Progress (Local)</title>
  <style>
    :root {
      --primary-color: #007bff;
      --primary-hover-color: #0056b3;
      --background-color: #f8f9fa;
      --container-bg-color: #ffffff;
      --text-color: #343a40;
      --muted-text-color: #6c757d;
      --border-color: #dee2e6;
      --light-gray-bg: #e9ecef;
      --header-bg-color: #f1f3f5;
      --today-line-color: #dc3545;
      --drag-over-border-color: #007bff;
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      --border-radius: 6px;

      /* --- Column widths --- */
      --task-name-column-width: 200px;
      --task-percent-column-width: 70px; /* Adjust width as desired */
      --date-column-width: 65px;
    }

    body {
      font-family: var(--font-family);
      margin: 0;
      padding: 30px;
      background-color: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
      user-select: none;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background-color: var(--container-bg-color);
      padding: 30px;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      position: relative;
    }

    h1 {
      text-align: center;
      color: var(--text-color);
      margin-bottom: 30px;
      font-weight: 700;
    }

    .gantt-legend {
      position: absolute;
      top: 25px;
      right: 30px;
      background-color: rgba(255, 255, 255, 0.85);
      padding: 8px 12px;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border: 1px solid var(--border-color);
      z-index: 10;
      backdrop-filter: blur(2px);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-key {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    .legend-key.stripe-key {
      background-color: #adb5bd;
      background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.25) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.25) 50%, rgba(255, 255, 255, 0.25) 75%, transparent 75%, transparent);
      background-size: 10px 10px;
    }
    .legend-text {
      font-size: 0.85em;
      color: var(--muted-text-color);
    }
    .controls {
      margin-bottom: 30px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 20px;
      font-family: var(--font-family);
      font-weight: 500;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    button:hover {
      background-color: var(--primary-hover-color);
      transform: translateY(-1px);
    }
    button:active {
      transform: translateY(0);
    }
    #cancel-task {
      background-color: var(--muted-text-color);
    }
    #cancel-task:hover {
      background-color: #5a6268;
    }

    .gantt-container {
      overflow-x: auto;
      overflow-y: hidden; /* Prevent vertical scroll */
      margin-top: 25px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      position: relative;
    }
    table.gantt {
      border-collapse: collapse;
      width: 100%;
      border-spacing: 0;
      table-layout: fixed;
    }
    table.gantt th,
    table.gantt td {
      padding: 12px 10px;
      vertical-align: middle;
      border: none;
      white-space: nowrap;
    }
    table.gantt thead tr {
      border-bottom: 2px solid var(--border-color);
    }

    /* --- General header style --- */
    table.gantt th {
      font-weight: 500;
      text-align: center;
      border-right: 1px solid var(--border-color);
      width: var(--date-column-width);
      position: sticky;
      top: 0;
      background-color: var(--header-bg-color);
      z-index: 2;
    }

    /* --- Sticky header for the Task column --- */
    table.gantt th.sticky-col-1 {
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 5; /* Above other columns */
      background-color: var(--header-bg-color);
      width: var(--task-name-column-width);
      border-right: 1px solid var(--border-color);
    }

    /* --- Sticky header for the Percentage column --- */
    table.gantt th.sticky-col-2,
    table.gantt tbody td.sticky-col-2 {
      text-align: center;
      background-color: var(--header-bg-color);
      border-right: 1px solid var(--border-color);
      
      /* Fixed width properties */
      width: var(--task-percent-column-width);
      min-width: var(--task-percent-column-width);
      max-width: var(--task-percent-column-width);
    }
    table.gantt th.sticky-col-2 {
      position: sticky;
      left: var(--task-name-column-width);
      z-index: 5;
    }
    table.gantt tbody td.sticky-col-2 {
      position: sticky;
      left: var(--task-name-column-width);
      z-index: 2;
      background-color: var(--container-bg-color);
      font-size: 0.9em;
      color: var(--muted-text-color);
    }
    table.gantt th:last-child {
      border-right: none;
    }

    /* --- Resize Handle Style --- */
    .resize-handle {
      position: absolute;
      top: 0;
      right: -3px;
      bottom: 0;
      width: 6px;
      cursor: col-resize;
      z-index: 4;
    }

    table.gantt tbody tr {
      border-bottom: 1px solid var(--border-color);
      transition: background-color 0.15s ease, opacity 0.2s ease;
    }
    table.gantt tbody tr:last-child {
      border-bottom: none;
    }
    table.gantt tbody tr:hover {
      background-color: #f1f3f5;
    }

    /* --- Sticky data columns --- */
    table.gantt tbody td.sticky-col-1 {
      position: sticky;
      left: 0;
      z-index: 2;
      background-color: var(--container-bg-color);
      border-right: 1px solid var(--border-color);
      width: var(--task-name-column-width);
      overflow: hidden;
    }
    table.gantt tbody td.sticky-col-2 {
      /* Already defined above as a sticky column with fixed width */
    }

    table.gantt tbody td:nth-child(3) {
      padding: 0;
      vertical-align: middle;
      position: relative;
    }

    .gantt-row {
      height: 50px;
      cursor: grab;
    }
    .gantt-row.dragging {
      opacity: 0.5;
      cursor: grabbing;
      background-color: var(--light-gray-bg);
    }
    .gantt-row.drag-over-top {
      border-top: 3px solid var(--drag-over-border-color);
    }
    .gantt-row.drag-over-bottom {
      border-bottom: 3px solid var(--drag-over-border-color);
    }

    .task-name-cell {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      width: 100%;
      overflow: hidden;
    }
    .task-name-text {
      flex-grow: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
      white-space: nowrap;
    }
    .task-actions {
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }
    .task-actions button {
      background: none;
      border: none;
      padding: 0;
      margin-left: 8px;
      cursor: pointer;
      font-size: 1.1em;
      color: var(--muted-text-color);
      transition: color 0.2s ease;
      flex-shrink: 0;
    }
    .task-actions button:hover {
      color: var(--text-color);
      background: none;
      transform: none;
    }

    .gantt-chart {
      position: relative;
      height: 100%;
      min-height: 30px;
      margin: 0 -10px;
      padding: 10px 0;
    }
    .task-bar {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 60%;
      background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
      background-size: 40px 40px;
      border-radius: 4px;
      color: white;
      display: flex;
      align-items: center;
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
      font-size: 0.85em;
      font-weight: 500;
      transition: all 0.2s ease;
      z-index: 1;
      overflow: hidden;
    }
    .task-bar:hover {
      filter: brightness(1.1);
    }
    .task-progress {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      border-radius: 4px 0 0 4px;
      transition: width 0.3s ease;
      z-index: 1;
      background-color: inherit;
      filter: brightness(0.9);
    }
    .task-bar[style*="width: 100%"] .task-progress {
      border-radius: 4px;
    }
    .task-bar-text {
      padding: 0 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      position: relative;
      z-index: 2;
      flex-grow: 1;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    .task-form {
      margin-bottom: 30px;
      padding: 25px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: #fdfdff;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
    }
    .form-group {
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    .form-group label {
      flex-basis: 100px;
      flex-shrink: 0;
      font-weight: 500;
      text-align: right;
    }
    input[type="text"],
    input[type="date"],
    select,
    input[type="number"] {
      flex-grow: 1;
      min-width: 150px;
      max-width: 300px;
      padding: 10px 12px;
      font-family: var(--font-family);
      font-size: 1em;
      border: 1px solid #ced4da;
      border-radius: var(--border-radius);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    input[type="text"]:focus,
    input[type="date"]:focus,
    select:focus,
    input[type="number"]:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      outline: none;
    }
    .form-group > div {
      flex-basis: calc(100% - 115px);
      display: flex;
      gap: 10px;
    }
    .hide {
      display: none;
    }

    .date-guides td {
      padding: 0;
      height: 0;
      border: none;
    }
    .date-guide-cell {
      position: relative;
      height: 0;
      border: none;
    }
    .grid-line {
      position: absolute;
      top: -5000px;
      bottom: 0;
      width: 1px;
      background-color: var(--border-color);
      pointer-events: none;
      z-index: 0;
      height: 10000px;
    }

    #today-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background-color: var(--today-line-color);
      z-index: 4;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Gantt Chart Planning & Progress (Local)</h1>
    <div class="gantt-legend">
      <div class="legend-item">
        <span class="legend-key stripe-key"></span>
        <span class="legend-text">Not Completed</span>
      </div>
    </div>
    <div class="controls">
      <button id="add-task">Add Task</button>
      <button id="save-chart">Save Chart</button>
      <button id="load-chart">Load Chart</button>
      <button id="export-csv">Export CSV</button>
    </div>
    <div id="task-form" class="task-form hide">
      <input type="hidden" id="task-id">
      <div class="form-group">
        <label for="task-name">Task Name:</label>
        <input type="text" id="task-name" placeholder="e.g. Design Phase" />
      </div>
      <div class="form-group">
        <label for="start-date">Start Date:</label>
        <input type="date" id="start-date" />
      </div>
      <div class="form-group">
        <label for="end-date">End Date:</label>
        <input type="date" id="end-date" />
      </div>
      <div class="form-group">
        <label for="task-color">Color:</label>
        <select id="task-color">
          <option value="#0d6efd">Blue</option>
          <option value="#6f42c1">Purple</option>
          <option value="#198754">Green</option>
          <option value="#dc3545">Red</option>
          <option value="#ffc107">Yellow</option>
          <option value="#fd7e14">Orange</option>
          <option value="#6c757d">Gray</option>
        </select>
      </div>
      <div class="form-group">
        <label for="task-completion">Completion (%):</label>
        <input type="number" id="task-completion" min="0" max="100" step="1" value="0" placeholder="0-100" />
      </div>
      <div class="form-group">
        <label></label>
        <div>
          <button id="save-task">Save Task</button>
          <button id="cancel-task" type="button">Cancel</button>
        </div>
      </div>
    </div>
    <div class="gantt-container" id="gantt-container">
      <table class="gantt" id="gantt-table">
        <thead>
          <tr id="header-row">
            <!-- Headers added dynamically -->
          </tr>
        </thead>
        <tbody id="gantt-tbody">
          <!-- Rows added dynamically -->
        </tbody>
      </table>
      <div id="today-line"></div>
    </div>
  </div>

  <script>
    // Initial tasks
    const currentYear = new Date().getFullYear();
    var tasks = [
      { id: 1, name: 'Initial Planning & Research', startDate: `${currentYear}-04-02`, endDate: `${currentYear}-04-10`, color: '#0d6efd', completion: 100 },
      { id: 2, name: 'Design Mockups', startDate: `${currentYear}-04-05`, endDate: `${currentYear}-04-15`, color: '#6f42c1', completion: 75 },
      { id: 3, name: 'Frontend Development - A very long name to test ellipsis functionality', startDate: `${currentYear}-04-10`, endDate: `${currentYear}-04-25`, color: '#198754', completion: 30 },
      { id: 4, name: 'Backend Development', startDate: `${currentYear}-04-16`, endDate: `${currentYear}-05-05`, color: '#fd7e14', completion: 10 },
      { id: 5, name: 'Testing', startDate: `${currentYear}-05-01`, endDate: `${currentYear}-05-10`, color: '#dc3545', completion: 0 },
      { id: 6, name: 'Deployment', startDate: `${currentYear}-05-11`, endDate: `${currentYear}-05-15`, color: '#6f42c1', completion: 0 }
    ];

    // DOM elements
    var ganttContainer = document.getElementById('gantt-container');
    var ganttTable = document.getElementById('gantt-table');
    var ganttBody = document.getElementById('gantt-tbody');
    var addTaskBtn = document.getElementById('add-task');
    var saveChartBtn = document.getElementById('save-chart');
    var loadChartBtn = document.getElementById('load-chart');
    var exportCsvBtn = document.getElementById('export-csv');
    var taskForm = document.getElementById('task-form');
    var saveTaskBtn = document.getElementById('save-task');
    var cancelTaskBtn = document.getElementById('cancel-task');
    var taskIdInput = document.getElementById('task-id');
    var todayLine = document.getElementById('today-line');
    var rootStyle = document.documentElement.style;
    var currentEditingTaskId = null;
    var currentlyDraggedElement = null;
    var dates = [];
    var isResizing = false;
    var initialTaskColWidth = 0;
    var initialResizeX = 0;

    // --- DATE UTILS ---
    function formatDate(date, format = 'iso') {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      switch (format) {
        case 'iso': return `${year}-${month}-${day}`;
        case 'short': return `${day}/${month}`;
        case 'display': return `${day}/${month}/${year}`;
        default: return date.toDateString();
      }
    }
    function parseDate(dateString) {
      if (!dateString) return null;
      const parts = dateString.split('-');
      if (parts.length !== 3) return null;
      const year = parseInt(parts[0], 10);
      const month = parseInt(parts[1], 10);
      const day = parseInt(parts[2], 10);
      if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
      const date = new Date(Date.UTC(year, month - 1, day));
      if (date.getUTCFullYear() !== year || date.getUTCMonth() !== month - 1 || date.getUTCDate() !== day) {
        return null;
      }
      return date;
    }
    function getStartOfDay(date) {
      const newDate = new Date(date);
      newDate.setUTCHours(0, 0, 0, 0);
      return newDate;
    }

    // --- CHART GENERATION ---
    function initChart() {
      tasks = tasks.map(task => ({
        ...task,
        completion: task.completion !== undefined ? parseInt(task.completion, 10) : 0,
        startDateObj: parseDate(task.startDate),
        endDateObj: parseDate(task.endDate)
      })).filter(task => task.startDateObj && task.endDateObj);
      if (tasks.length === 0 && localStorage.getItem('ganttChartDataModernLocal')) {
        loadChart(true);
        return;
      } else if (tasks.length === 0) {
        console.warn("No valid tasks to display.");
      }
      initialTaskColWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--task-name-column-width'), 10);
      dates = getDateRange();
      generateHeaders(dates);
      generateTaskRows(dates);
      updateTodayLine(dates);
      setupDragAndDrop();
      scrollToTodayView();
    }
    function getDateRange() {
      if (tasks.length === 0) {
        const today = getStartOfDay(new Date());
        const start = new Date(today);
        start.setDate(today.getDate() - 7);
        const end = new Date(today);
        end.setDate(today.getDate() + 30);
        return generateDateRange(start, end);
      }
      let minDate = tasks[0].startDateObj, maxDate = tasks[0].endDateObj;
      tasks.forEach(task => {
        if (task.startDateObj < minDate) minDate = task.startDateObj;
        if (task.endDateObj > maxDate) maxDate = task.endDateObj;
      });
      const today = getStartOfDay(new Date());
      let startRange = new Date(Math.min(minDate, today));
      let endRange = new Date(Math.max(maxDate, today));
      startRange.setDate(startRange.getDate() - 7);
      endRange.setDate(endRange.getDate() + 14);
      const diffTime = Math.abs(endRange - startRange);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      if (diffDays < 21) { endRange.setDate(startRange.getDate() + 21); }
      return generateDateRange(startRange, endRange);
    }
    function generateDateRange(start, end) {
      const dateArray = [];
      let current = getStartOfDay(new Date(start));
      const finalEnd = getStartOfDay(new Date(end));
      if (isNaN(current) || isNaN(finalEnd)) {
        console.error("Invalid start or end date for range generation:", start, end);
        return [];
      }
      while (current <= finalEnd) {
        dateArray.push(new Date(current));
        current.setUTCDate(current.getUTCDate() + 1);
      }
      return dateArray;
    }
    function generateHeaders(dates) {
      const headerRow = document.getElementById('header-row');
      headerRow.innerHTML = '';
      const taskTh = document.createElement('th');
      taskTh.textContent = 'Task';
      taskTh.className = 'sticky-col-1';
      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      resizeHandle.addEventListener('mousedown', handleMouseDownOnResize);
      taskTh.appendChild(resizeHandle);
      headerRow.appendChild(taskTh);
      const percentTh = document.createElement('th');
      percentTh.textContent = '%';
      percentTh.className = 'sticky-col-2';
      headerRow.appendChild(percentTh);
      if (dates && dates.length > 0) {
        dates.forEach(date => {
          const th = document.createElement('th');
          th.textContent = formatDate(date, 'short');
          const dayOfWeek = date.getUTCDay();
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            th.style.backgroundColor = '#f0f2f4';
          }
          if (date.getUTCDate() === 1) { th.style.fontWeight = 'bold'; }
          headerRow.appendChild(th);
        });
      }
    }
    function generateTaskRows(dates) {
      ganttBody.innerHTML = '';
      if (!dates || dates.length === 0) return;
      const totalDaysInView = dates.length;
      const dayWidthPercentage = 100 / totalDaysInView;
      tasks.forEach(task => {
        const row = document.createElement('tr');
        row.className = 'gantt-row';
        row.dataset.taskId = task.id;
        row.setAttribute('draggable', 'true');
        const nameCell = document.createElement('td');
        nameCell.className = 'sticky-col-1';
        const taskNameDiv = document.createElement('div');
        taskNameDiv.className = 'task-name-cell';
        const taskNameSpan = document.createElement('span');
        taskNameSpan.className = 'task-name-text';
        taskNameSpan.textContent = task.name;
        taskNameSpan.title = task.name;
        const actionButtonsDiv = document.createElement('div');
        actionButtonsDiv.className = 'task-actions';
        const editBtn = document.createElement('button');
        editBtn.innerHTML = '✏️';
        editBtn.title = "Edit Task";
        editBtn.onclick = (e) => { e.stopPropagation(); editTask(task.id); };
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '🗑️';
        deleteBtn.title = "Delete Task";
        deleteBtn.onclick = (e) => { e.stopPropagation(); deleteTask(task.id); };
        actionButtonsDiv.appendChild(editBtn);
        actionButtonsDiv.appendChild(deleteBtn);
        // You can add an extra spacer here if desired. If resizing of the % column suffices, this extra element can be omitted.
        // const spacer = document.createElement('div');
        // spacer.className = 'resize-handle';
        // actionButtonsDiv.appendChild(spacer);
        taskNameDiv.appendChild(taskNameSpan);
        taskNameDiv.appendChild(actionButtonsDiv);
        nameCell.appendChild(taskNameDiv);
        row.appendChild(nameCell);
        const percentCell = document.createElement('td');
        percentCell.className = 'sticky-col-2';
        percentCell.textContent = `${task.completion}%`;
        row.appendChild(percentCell);
        const dateCell = document.createElement('td');
        dateCell.colSpan = dates.length;
        const chartDiv = document.createElement('div');
        chartDiv.className = 'gantt-chart';
        const startDate = task.startDateObj, endDate = task.endDateObj;
        const startIdx = findDateIndex(dates, startDate);
        const endIdxInclusive = findDateIndex(dates, endDate);
        if (startIdx !== -1 && endIdxInclusive !== -1 && endIdxInclusive >= startIdx) {
          const taskDurationDays = endIdxInclusive - startIdx + 1;
          const startOffsetPercentage = (startIdx * dayWidthPercentage) + 0.2;
          const taskWidthPercentage = (taskDurationDays * dayWidthPercentage) - 0.3;
          const taskBar = document.createElement('div');
          taskBar.className = 'task-bar';
          taskBar.style.left = `${startOffsetPercentage}%`;
          taskBar.style.width = `${taskWidthPercentage}%`;
          taskBar.style.backgroundColor = task.color;
          taskBar.title = `${task.name}: ${formatDate(startDate, 'display')} - ${formatDate(endDate, 'display')} (${task.completion}%)`;
          const taskProgress = document.createElement('div');
          taskProgress.className = 'task-progress';
          taskProgress.style.width = `${task.completion}%`;
          taskProgress.style.backgroundColor = task.color;
          taskProgress.style.filter = 'brightness(90%)';
          if(task.completion === 100) { taskProgress.style.borderRadius = '4px'; }
          taskBar.appendChild(taskProgress);
          const taskBarText = document.createElement('span');
          taskBarText.className = 'task-bar-text';
          taskBarText.textContent = task.name;
          taskBar.appendChild(taskBarText);
          chartDiv.appendChild(taskBar);
        }
        dateCell.appendChild(chartDiv);
        row.appendChild(dateCell);
        ganttBody.appendChild(row);
      });
      // Optionally, if you don't need gridlines, comment out this call:
      // addGridLines(ganttBody, dates.length);
    }
    function addGridLines(tbody, dateCount) {
      if (dateCount <= 0) return;
      const existingGrid = tbody.querySelector('.date-guides');
      if (existingGrid) existingGrid.remove();
      const gridRow = document.createElement('tr');
      gridRow.className = 'date-guides';
      gridRow.style.height = '0';
      gridRow.style.border = 'none';
      gridRow.setAttribute('draggable', 'false');
      const stickyCell1 = document.createElement('td');
      stickyCell1.style.padding = '0';
      stickyCell1.style.border = 'none';
      stickyCell1.className = 'sticky-col-1';
      stickyCell1.style.backgroundColor = 'var(--container-bg-color)';
      stickyCell1.style.borderRight = '1px solid var(--border-color)';
      gridRow.appendChild(stickyCell1);
      const stickyCell2 = document.createElement('td');
      stickyCell2.style.padding = '0';
      stickyCell2.style.border = 'none';
      stickyCell2.className = 'sticky-col-2';
      stickyCell2.style.backgroundColor = 'var(--container-bg-color)';
      stickyCell2.style.borderRight = '1px solid var(--border-color)';
      gridRow.appendChild(stickyCell2);
      const guidesCell = document.createElement('td');
      guidesCell.colSpan = dateCount;
      guidesCell.style.position = 'relative';
      guidesCell.style.padding = '0';
      guidesCell.style.border = 'none';
      guidesCell.className = 'date-guide-cell';
      const dayWidthPercentage = 100 / dateCount;
      for (let i = 0; i < dateCount; i++) {
        const line = document.createElement('div');
        line.className = 'grid-line';
        const leftPercent = i * dayWidthPercentage;
        line.style.left = `${leftPercent}%`;
        guidesCell.appendChild(line);
      }
      const finalLine = document.createElement('div');
      finalLine.className = 'grid-line';
      finalLine.style.left = '100%';
      guidesCell.appendChild(finalLine);
      gridRow.appendChild(guidesCell);
      tbody.prepend(gridRow);
    }
    function findDateIndex(datesArray, targetDate) {
      if (!targetDate || !datesArray || datesArray.length === 0) return -1;
      const targetTime = getStartOfDay(targetDate).getTime();
      return datesArray.findIndex(d => d.getTime() === targetTime);
    }
    function updateTodayLine(dates) {
      const headerRow = document.getElementById('header-row');
      if (!headerRow || headerRow.children.length < 3 || !dates || dates.length === 0) {
        todayLine.style.display = 'none';
        return;
      }
      const today = getStartOfDay(new Date());
      const todayIndex = findDateIndex(dates, today);
      if (todayIndex !== -1) {
        const taskColWidth = headerRow.children[0].offsetWidth;
        const percentColWidth = headerRow.children[1].offsetWidth;
        const dateHeaders = Array.from(headerRow.children).slice(2);
        if (dateHeaders.length !== dates.length) {
          console.warn("Header count mismatch.");
          todayLine.style.display = 'none';
          return;
        }
        let offsetLeft = taskColWidth + percentColWidth;
        for(let i = 0; i < todayIndex; i++) {
          if(dateHeaders[i]) {
            offsetLeft += dateHeaders[i].offsetWidth;
          } else {
            console.warn(`Missing header index ${i}.`);
            todayLine.style.display = 'none';
            return;
          }
        }
        if (dateHeaders[todayIndex]) {
          offsetLeft += dateHeaders[todayIndex].offsetWidth / 2;
        } else {
          console.warn(`Missing header index ${todayIndex}.`);
          todayLine.style.display = 'none';
          return;
        }
        todayLine.style.left = `${offsetLeft}px`;
        todayLine.style.top = `${headerRow.offsetHeight}px`;
        todayLine.style.height = `${ganttTable.offsetHeight - headerRow.offsetHeight}px`;
        todayLine.style.display = 'block';
      } else {
        todayLine.style.display = 'none';
      }
    }

    // --- DRAG AND DROP ---
    function setupDragAndDrop() {
      const rows = ganttBody.querySelectorAll('tr.gantt-row');
      rows.forEach(row => {
        row.removeEventListener('dragstart', handleDragStart);
        row.removeEventListener('dragover', handleDragOver);
        row.removeEventListener('dragleave', handleDragLeave);
        row.removeEventListener('drop', handleDrop);
        row.removeEventListener('dragend', handleDragEnd);
        row.addEventListener('dragstart', handleDragStart);
        row.addEventListener('dragover', handleDragOver);
        row.addEventListener('dragleave', handleDragLeave);
        row.addEventListener('drop', handleDrop);
        row.addEventListener('dragend', handleDragEnd);
      });
    }
    function handleDragStart(e) {
      if (e.target.closest('button')) { e.preventDefault(); return; }
      currentlyDraggedElement = this;
      e.dataTransfer.effectAllowed = 'move';
      try { e.dataTransfer.setData('text/plain', this.dataset.taskId); }
      catch (err) { console.error("Error setting drag data:", err) }
      setTimeout(() => { if (currentlyDraggedElement) currentlyDraggedElement.classList.add('dragging'); }, 0);
    }
    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const targetRow = this;
      if (!currentlyDraggedElement || targetRow === currentlyDraggedElement || !targetRow.classList.contains('gantt-row')) {
        clearDragOverStyles();
        return;
      }
      const rect = targetRow.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      const isAfter = e.clientY > midpoint;
      clearDragOverStyles();
      targetRow.classList.add(isAfter ? 'drag-over-bottom' : 'drag-over-top');
    }
    function handleDragLeave(e) {
      if (!this.contains(e.relatedTarget)) { this.classList.remove('drag-over-top', 'drag-over-bottom'); }
    }
    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const droppedOnElement = this;
      clearDragOverStyles();
      if (!currentlyDraggedElement || droppedOnElement === currentlyDraggedElement || !droppedOnElement.classList.contains('gantt-row')) {
        if(currentlyDraggedElement) handleDragEnd.call(currentlyDraggedElement);
        return;
      }
      const draggedTaskIdStr = e.dataTransfer.getData('text/plain');
      if (!draggedTaskIdStr) {
        console.error("Could not get dragged task ID");
        if(currentlyDraggedElement) handleDragEnd.call(currentlyDraggedElement);
        return;
      }
      const draggedTaskId = parseInt(draggedTaskIdStr, 10);
      const targetTaskId = parseInt(droppedOnElement.dataset.taskId, 10);
      const draggedTaskIndex = tasks.findIndex(task => task.id === draggedTaskId);
      const targetTaskIndex = tasks.findIndex(task => task.id === targetTaskId);
      if (draggedTaskIndex === -1 || targetTaskIndex === -1 || isNaN(draggedTaskId) || isNaN(targetTaskId)) {
        console.error("Task find error on drop.", { draggedTaskId, targetTaskId, draggedTaskIndex, targetTaskIndex });
        if(currentlyDraggedElement) handleDragEnd.call(currentlyDraggedElement);
        return;
      }
      const rect = droppedOnElement.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      const insertAfter = e.clientY > midpoint;
      const [draggedTask] = tasks.splice(draggedTaskIndex, 1);
      const adjustedTargetIndex = (draggedTaskIndex < targetTaskIndex) ? targetTaskIndex - 1 : targetTaskIndex;
      let newIndex = insertAfter ? adjustedTargetIndex + 1 : adjustedTargetIndex;
      tasks.splice(newIndex, 0, draggedTask);
      initChart();
      if(currentlyDraggedElement) handleDragEnd.call(currentlyDraggedElement);
    }
    function handleDragEnd(e) {
      if (this && this.classList) { this.classList.remove('dragging'); }
      clearDragOverStyles();
      currentlyDraggedElement = null;
    }
    function clearDragOverStyles() {
      ganttBody.querySelectorAll('.gantt-row').forEach(row => row.classList.remove('drag-over-top', 'drag-over-bottom'));
    }

    // --- COLUMN RESIZE LOGIC ---
    function handleMouseDownOnResize(e) {
      isResizing = true;
      initialResizeX = e.clientX;
      initialTaskColWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--task-name-column-width'), 10);
      document.addEventListener('mousemove', handleMouseMoveResize);
      document.addEventListener('mouseup', handleMouseUpResize);
      ganttContainer.style.cursor = 'col-resize';
      document.body.style.cursor = 'col-resize';
    }
    function handleMouseMoveResize(e) {
      if (!isResizing) return;
      const deltaX = e.clientX - initialResizeX;
      let newWidth = initialTaskColWidth + deltaX;
      const minWidth = 80;
      if (newWidth < minWidth) { newWidth = minWidth; }
      rootStyle.setProperty('--task-name-column-width', `${newWidth}px`);
    }
    function handleMouseUpResize(e) {
      if (isResizing) {
        isResizing = false;
        document.removeEventListener('mousemove', handleMouseMoveResize);
        document.removeEventListener('mouseup', handleMouseUpResize);
        ganttContainer.style.cursor = 'default';
        document.body.style.cursor = 'default';
        updateTodayLine(dates);
      }
    }

    // --- TASK ACTIONS ---
    function showTaskForm(task = null) {
      if (task) {
        taskIdInput.value = task.id;
        document.getElementById('task-name').value = task.name;
        document.getElementById('start-date').value = task.startDate;
        document.getElementById('end-date').value = task.endDate;
        document.getElementById('task-color').value = task.color;
        document.getElementById('task-completion').value = task.completion !== undefined ? task.completion : 0;
        currentEditingTaskId = task.id;
        saveTaskBtn.textContent = "Update Task";
      } else {
        taskIdInput.value = '';
        document.getElementById('task-name').value = '';
        document.getElementById('start-date').value = formatDate(new Date(), 'iso');
        document.getElementById('end-date').value = '';
        document.getElementById('task-color').value = '#0d6efd';
        document.getElementById('task-completion').value = 0;
        currentEditingTaskId = null;
        saveTaskBtn.textContent = "Save Task";
      }
      taskForm.classList.remove('hide');
      document.getElementById('task-name').focus();
    }
    function hideTaskForm() {
      taskForm.classList.add('hide');
      taskIdInput.value = '';
      document.getElementById('task-name').value = '';
      document.getElementById('start-date').value = '';
      document.getElementById('end-date').value = '';
      document.getElementById('task-color').value = '#0d6efd';
      document.getElementById('task-completion').value = 0;
      currentEditingTaskId = null;
      saveTaskBtn.textContent = "Save Task";
    }
    function saveTask() {
      const name = document.getElementById('task-name').value.trim();
      const startDateStr = document.getElementById('start-date').value;
      const endDateStr = document.getElementById('end-date').value;
      const color = document.getElementById('task-color').value;
      const completionInput = document.getElementById('task-completion');
      let completion = parseInt(completionInput.value, 10);
      const idToSave = currentEditingTaskId;
      if (!name || !startDateStr || !endDateStr) {
        alert('Please fill in Task Name, Start Date, and End Date.');
        return;
      }
      if (isNaN(completion) || completion < 0) { completion = 0; }
      else if (completion > 100) { completion = 100; }
      completionInput.value = completion;
      const startDate = parseDate(startDateStr);
      const endDate = parseDate(endDateStr);
      if (!startDate || !endDate) {
        alert('Invalid date format. Please use YYYY-MM-DD.');
        return;
      }
      if (startDate > endDate) {
        alert('End Date must be on or after Start Date.');
        return;
      }
      if (idToSave !== null) {
        const taskIndex = tasks.findIndex(t => t.id === idToSave);
        if (taskIndex > -1) {
          tasks[taskIndex] = {
            ...tasks[taskIndex],
            name,
            startDate: startDateStr,
            endDate: endDateStr,
            color,
            completion,
            startDateObj: startDate,
            endDateObj: endDate
          };
        } else {
          console.error("Could not find task to update with ID:", idToSave);
          alert("Error updating task. Task not found.");
          return;
        }
      } else {
        const newId = tasks.length > 0 ? Math.max(...tasks.map(t => t.id)) + 1 : 1;
        tasks.push({
          id: newId,
          name,
          startDate: startDateStr,
          endDate: endDateStr,
          color,
          completion,
          startDateObj: startDate,
          endDateObj: endDate
        });
      }
      hideTaskForm();
      initChart();
    }
    function editTask(taskId) {
      const taskToEdit = tasks.find(t => t.id === taskId);
      if (taskToEdit) {
        showTaskForm(taskToEdit);
      }
    }
    function deleteTask(taskId) {
      const taskName = tasks.find(t=>t.id===taskId)?.name || `ID ${taskId}`;
      if (confirm(`Are you sure you want to delete task "${taskName}"?`)) {
        tasks = tasks.filter(task => task.id !== taskId);
        initChart();
      }
    }

    // --- CHART SAVE/LOAD/EXPORT ---
    function saveChart() {
      const dataToSave = tasks.map(({ id, name, startDate, endDate, color, completion }) => ({ id, name, startDate, endDate, color, completion }));
      try {
        localStorage.setItem('ganttChartDataModernLocal', JSON.stringify(dataToSave));
        alert('Chart saved successfully!');
      } catch (e) {
        console.error("Error saving chart:", e);
        alert('Error saving chart.');
      }
    }
    function loadChart(calledInternally = false) {
      const savedData = localStorage.getItem('ganttChartDataModernLocal');
      if (savedData) {
        try {
          const loadedTasks = JSON.parse(savedData);
          if (Array.isArray(loadedTasks) && loadedTasks.every(t => t.id && t.name && t.startDate && t.endDate)) {
            tasks = loadedTasks.map(task => ({
              ...task,
              completion: task.completion !== undefined && !isNaN(parseInt(task.completion, 10)) ? parseInt(task.completion, 10) : 0,
            }));
            if (!calledInternally) { initChart(); alert('Chart loaded successfully!'); }
            else { console.log("Saved chart data loaded internally."); }
          } else {
            alert('Invalid data format found in local storage.');
            localStorage.removeItem('ganttChartDataModernLocal');
          }
        } catch (e) {
          console.error("Error parsing saved chart data:", e);
          alert('Error loading chart data.');
          localStorage.removeItem('ganttChartDataModernLocal');
        }
      } else {
        if (!calledInternally) alert('No saved chart data found.');
      }
    }
    function exportCsv() {
      if (tasks.length === 0) { alert("No tasks to export."); return; }
      let csvContent = 'Order,Task Name,Start Date,End Date,Color,Completion %\n';
      tasks.forEach((task, index) => {
        const escapedName = `"${task.name.replace(/"/g, '""')}"`;
        csvContent += `${index + 1},${escapedName},${task.startDate},${task.endDate},${task.color},${task.completion}\n`;
      });
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', 'gantt_chart_export.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    // --- SCROLL TO VIEW LOGIC ---
    function scrollToTodayView() {
      if (!ganttContainer || !dates || dates.length === 0) return;
      const headerRow = document.getElementById('header-row');
      if (!headerRow || headerRow.children.length < 3) return;
      const today = getStartOfDay(new Date());
      let yesterday = new Date(today);
      yesterday.setDate(today.getDate() - 1);
      yesterday = getStartOfDay(yesterday);
      let targetDateIndex = findDateIndex(dates, yesterday);
      if (targetDateIndex === -1) {
        const todayIndex = findDateIndex(dates, today);
        if (todayIndex !== -1) { targetDateIndex = Math.max(0, todayIndex - 1); }
        else { targetDateIndex = 0; }
      }
      const dateColWidth = headerRow.children[2]?.offsetWidth;
      if (dateColWidth && dateColWidth > 0) {
         const scrollPos = targetDateIndex * dateColWidth;
         requestAnimationFrame(() => { ganttContainer.scrollLeft = scrollPos; });
      } else {
         console.warn("Could not determine date column width for scrolling.");
         requestAnimationFrame(() => { ganttContainer.scrollLeft = 0; });
      }
    }

    // --- EVENT LISTENERS ---
    addTaskBtn.addEventListener('click', () => showTaskForm());
    saveTaskBtn.addEventListener('click', saveTask);
    cancelTaskBtn.addEventListener('click', hideTaskForm);
    saveChartBtn.addEventListener('click', saveChart);
    loadChartBtn.addEventListener('click', () => loadChart());
    exportCsvBtn.addEventListener('click', exportCsv);
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => { if (dates.length > 0) { updateTodayLine(dates); } }, 150);
    });
    window.addEventListener('load', () => { initChart(); });
  </script>
</body>
</html>
